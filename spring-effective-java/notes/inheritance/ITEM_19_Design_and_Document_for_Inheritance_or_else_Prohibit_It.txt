1. So what does it mean for a class to be designed and documented for inheritance?
- First, the class must document precisely the effects of overriding any method (documenting patterns of self-use)
    - the class must document its self-use of overridable methods
    - For each public or protected method in the class, 
      the documentation must indicate which overridable methods the method invokes, 
      in what sequence, and how the results of each invocation affect subsequent processing 
    - By overridable, we mean nonfinal and either public or protected.
    - More generally, a class must document any circumstances under which it might invoke an overridable method.
        - For example, invocations might come from background threads or static initializers.
    - A method that invokes overridable methods contains a description of these invocations at the end of its documentation comment.
        - The description is in a special section of the specification, labeled “Implementation Requirements,” which is generated by the Javadoc tag @implSpec.
        - the Javadoc tag @implSpec describes the inner workings of the method.
    - To document a class so that it can be safely subclassed, you must describe implementation details that should otherwise be left unspecified.
    - Documenting patterns of self-use 
    - To allow programmers to write efficient subclasses without undue pain, a class may have to provide hooks into its internal workings in the form of judiciously chosen protected methods or, in rare instances, protected fields. 
    - The only way to test a class designed for inheritance is to write subclasses
    - Experience shows that three subclasses are usually sufficient to test an extendable class. One or more of these subclasses should be written by someone other than the superclass author.
- Second, Constructors must not invoke overridable methods, directly or indirectly
    - The superclass constructor runs before the subclass constructor 
        - so the overriding method in the subclass will get invoked before the subclass constructor has run 
        - If the overriding method depends on any initialization performed by the subclass constructor, the method will not behave as expected.
        - Note that it is safe to invoke private methods, final methods, and static methods, none of which are overridable, from a constructor.
- The Cloneable and Serializable interfaces present special difficulties when designing for inheritance. 
    - It is generally not a good idea for a class designed for inheritance to implement either of these interfaces 
        - because they place a substantial burden on programmers who extend the class.
    - Neither `clone` nor `readObject` may invoke an overridable method, directly or indirectly
        - In the case of `readObject`, the overriding method will run before the subclass’s state has been deserialized
        - In the case of clone, the overriding method will run before the subclass’s clone method has a chance to fix the clone’s state
        - In either case, a program failure is likely to follow
            - In the case of clone, the failure can damage the original object as well as the clone
        - If implementing Serializable in a class designed for inheritance and the class has a readResolve or writeReplace method, 
            - you must make the readResolve or writeReplace method protected rather than private 
                - If these methods are private, they will be silently ignored by subclasses. 
                - This is one more case where an implementation detail becomes part of a class’s API to permit inheritance.
- Designing a class for inheritance requires great effort and places substantial limitations on the class.
- For ordinary concrete classes, they are neither final nor designed and documented for subclassing, this state of affairs is very dangerous
    - Each time a change is made in such a class, there is a chance that subclasses extending the class will break 
        - This is not just a theoretical problem. 
            - It is not uncommon to receive subclassing-related bug reports after modifying the internals of a nonfinal concrete class that was not designed and documented for inheritance 
    - The best solution to this problem is to prohibit subclassing in classes that are not designed and documented to be safely subclassed.
    - There are two ways to prohibit subclassing: 
        - The easier of the two is to declare the class final. 
        - The alternative is to make all the constructors private or package-private and to add public static factories in place of the constructors.
    - If a concrete class does not implement a standard interface, then you may inconvenience some programmers by prohibiting inheritance. 
        - If you feel that you must allow inheritance from such a class, one reasonable approach is to ensure that the class never invokes any of its overridable methods and to document this fact. 
        - In other words, eliminate the class's self-use of overridable methods entirely.
        - In doing so, you'll create a class that is reasonably safe to subclass, and overriding a method will never affect the behavior of any other method
    - You can eliminate a class’s self-use of overridable methods mechanically, without changing its behavior. 
        - Move the body of each overridable method to a private “helper method” and have each overridable method invoke its private helper method. 
            - Then replace each self-use of an overridable method with a direct invocation of the overridable method’s private helper method.